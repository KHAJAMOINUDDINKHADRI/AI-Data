import Papa from 'papaparse';
import * as XLSX from 'xlsx';
import { Client, Worker, Task } from '@/lib/contexts/DataContext';
import { Rule, PrioritizationWeights } from '@/lib/contexts/RulesContext';

interface ExportData {
  clients: Client[];
  workers: Worker[];
  tasks: Task[];
}

export function exportToCSV(data: ExportData) {
  // Export clients
  if (data.clients.length > 0) {
    const clientsCSV = Papa.unparse(data.clients.map(client => ({
      ...client,
      RequestedTaskIDs: Array.isArray(client.RequestedTaskIDs) ? client.RequestedTaskIDs.join(',') : client.RequestedTaskIDs,
      AttributesJSON: typeof client.AttributesJSON === 'object' ? JSON.stringify(client.AttributesJSON) : client.AttributesJSON
    })));
    downloadFile(clientsCSV, 'clients.csv', 'text/csv');
  }

  // Export workers
  if (data.workers.length > 0) {
    const workersCSV = Papa.unparse(data.workers.map(worker => ({
      ...worker,
      Skills: Array.isArray(worker.Skills) ? worker.Skills.join(',') : worker.Skills,
      AvailableSlots: Array.isArray(worker.AvailableSlots) ? worker.AvailableSlots.join(',') : worker.AvailableSlots
    })));
    downloadFile(workersCSV, 'workers.csv', 'text/csv');
  }

  // Export tasks
  if (data.tasks.length > 0) {
    const tasksCSV = Papa.unparse(data.tasks.map(task => ({
      ...task,
      RequiredSkills: Array.isArray(task.RequiredSkills) ? task.RequiredSkills.join(',') : task.RequiredSkills,
      PreferredPhases: Array.isArray(task.PreferredPhases) ? task.PreferredPhases.join(',') : task.PreferredPhases
    })));
    downloadFile(tasksCSV, 'tasks.csv', 'text/csv');
  }
}

export function exportToXLSX(data: ExportData) {
  const workbook = XLSX.utils.book_new();

  // Add clients sheet
  if (data.clients.length > 0) {
    const clientsData = data.clients.map(client => ({
      ...client,
      RequestedTaskIDs: Array.isArray(client.RequestedTaskIDs) ? client.RequestedTaskIDs.join(',') : client.RequestedTaskIDs,
      AttributesJSON: typeof client.AttributesJSON === 'object' ? JSON.stringify(client.AttributesJSON) : client.AttributesJSON
    }));
    const clientsSheet = XLSX.utils.json_to_sheet(clientsData);
    XLSX.utils.book_append_sheet(workbook, clientsSheet, 'Clients');
  }

  // Add workers sheet
  if (data.workers.length > 0) {
    const workersData = data.workers.map(worker => ({
      ...worker,
      Skills: Array.isArray(worker.Skills) ? worker.Skills.join(',') : worker.Skills,
      AvailableSlots: Array.isArray(worker.AvailableSlots) ? worker.AvailableSlots.join(',') : worker.AvailableSlots
    }));
    const workersSheet = XLSX.utils.json_to_sheet(workersData);
    XLSX.utils.book_append_sheet(workbook, workersSheet, 'Workers');
  }

  // Add tasks sheet
  if (data.tasks.length > 0) {
    const tasksData = data.tasks.map(task => ({
      ...task,
      RequiredSkills: Array.isArray(task.RequiredSkills) ? task.RequiredSkills.join(',') : task.RequiredSkills,
      PreferredPhases: Array.isArray(task.PreferredPhases) ? task.PreferredPhases.join(',') : task.PreferredPhases
    }));
    const tasksSheet = XLSX.utils.json_to_sheet(tasksData);
    XLSX.utils.book_append_sheet(workbook, tasksSheet, 'Tasks');
  }

  // Export the workbook
  const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
  const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'data-alchemist.xlsx';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

export function generateRulesJSON(rules: Rule[], weights: PrioritizationWeights) {
  return {
    metadata: {
      version: '1.0',
      generatedAt: new Date().toISOString(),
      generatedBy: 'Data Alchemist',
      description: 'Resource allocation configuration generated by Data Alchemist'
    },
    prioritization: {
      weights: weights,
      totalWeight: Object.values(weights).reduce((sum, weight) => sum + weight, 0)
    },
    businessRules: rules.map(rule => ({
      id: rule.id,
      type: rule.type,
      name: rule.name,
      description: rule.description,
      parameters: rule.parameters,
      enabled: rule.enabled,
      priority: rule.priority
    })),
    validation: {
      rulesCount: rules.length,
      activeRulesCount: rules.filter(r => r.enabled).length,
      ruleTypes: [...new Set(rules.map(r => r.type))]
    }
  };
}

function downloadFile(content: string, filename: string, contentType: string) {
  const blob = new Blob([content], { type: contentType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}